from Crypto.Util.number import inverse,long_to_bytes
#Encryption 1
N = 121551199555211805813518925300067630117775487008884239543905716493084387683712050881104174098165555577739016769330775280212492413657128638594742720676215003269566057169419234437208700352256489875784126395243723446099659602074558841282792435497113490277042031404205319357503271402383966625160207620777454819355
e1 = 65537
c1 =  1876191727132973053384118892572547463238488961538887969281727356174360316952783438165641697209466339683138531823502828623615969214238022068087500607309225459689917043504188468110057391537595809406088108165944165606434747401986807224797295778700566246197584491855396909892291505729826028045313481779888490208933685183222849064056723782035579537520692251217509954043281749433083559510060182248819493159206247690578325326617126308950461750358726434932687947612862549589063210077733885509391695689679024993875498008274715865857619688133582575897599463804027557771638218552896661943734362994775777187046496388758952151980

#Encryption 2
N2 =  2890795881161693571363915695556470159357182874134403344112452615861768650970647921412594467789018792944389359061357363973773337648034143319914986675389525865323549704700930536385930412217475872806768230768832390940437669358009894617085469274857608252315400204886746445352567869293034769200430641321668784312888727848452075499122487197661209219854097434468924425310889336999825786527917953997647268172998504634936659638732099371772004105878006624456489824754843838421454762041872085687750476676458087883737351478631472214306373400110429284926230693733391429337595469084741361886645814026029907636329424522136846322647

e2 = 257
c2 = 572459765480216918883292544859682919944001607738312873118675305149638576760966540231337372578427643839102868334217280659008369256953147937302250010092753147896786833972162848691935149209831943387842396339667855755147125988384834274700956460072540151136244433339606634252113462173393643377024414978752886650293201943268042762796129878460443053879742291127151908906571956790316545524465900990818296693575510158235474754918196221000616529819594512808308959890282519038935286532202817636571778359299480770818004740648977898715389318950968532217515323369137022975319539681950612847050903299923566280607880328567445208169

'''
assert N == N2

def egcd(a,b):
	if a==0:
		return (b,0,1)
	else:
		g,y,x = egcd(b%a,a)
		return (g,x-(b//a)*y,y)

def neg_pow(a, b, n):
	#assert b < 0
	#assert GCD(a, n) == 1
	res = inverse(a, n)
	res = pow(res, b*(-1), n)
	return res

g,a,b = egcd(e1,e2)
c1 = neg_pow(c1,a,N)

ctext = (c1*c2)% N
print(long_to_bytes(ctext))
'''

import gmpy2
from Crypto.Util.number import *

def egcd(a, b):
  if (a == 0):
    return (b, 0, 1)
  else:
    g, y, x = egcd(b % a, a)
    return (g, x - (b // a) * y, y)

# Calculates a^{b} mod n when b is negative
def neg_pow(a, b, n):
	assert b < 0
	#assert GCD(a, n) == 1
	#res = int(gmpy2.invert(a, n))
	res = inverse(a,n)
	res = pow(res, b*(-1), n)
	return res

# e1 --> Public Key exponent used to encrypt message m and get ciphertext c1
# e2 --> Public Key exponent used to encrypt message m and get ciphertext c2
# n --> Modulus
# The following attack works only when m^{GCD(e1, e2)} < n
def common_modulus(e1, e2, n, c1, c2):
	g, a, b = egcd(e1, e2)
	if a < 0:
		c1 = neg_pow(c1, a, n)
	else:
		c1 = pow(c1, a, n)
	if b < 0:
		c2 = neg_pow(c2, b, n)
	else:
		c2 = pow(c2, b, n)
	ct = c1*c2 % n
	print(g)
	#m = int(gmpy2.iroot(ct, g)[0])
	return long_to_bytes(m)

print(common_modulus(e1,e1,N,c1,c2))